/*
我们定义dp[i][j]为从点j出发经过除了出发点0以为的集合j
（这里的集合j是使用二进制表示的一个集合，比如1，3号点二进制表示维101=5，1，2，3号点可以表示为111=7）因此举个例子，如果有4个城市0，1，2，3号城市，那么从0号城市出发，最后经过1，2，3号城市最后回到0号城市可以表示为：

dp[0][{1,2,3}] = dp[0][7] = 
min{dis[0][1]+dp[1][{2,3}],dis[0][2]+dp[2][{1,3}],dis[0][3]+dp[3][{1,2}]}
dp[1][{2,3}]的意思就是从1号点出发，经过2，3号点最后回到0号点，其他都同理就不再赘述。

通过上式不断迭代最后有dp[1][{}] 
意思就是从1号点出发不经过任何点回到0的最短距离，那么这个距离直接就是dis[1][0]
其他以此类推。有了这个递推公式后就可以用动态规划解决了
当然这种方式还是一种用空间换时间的办法，当n很大的时候也会出现无法解决的情况，这就是NP问题的棘手和复杂之处。
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    int V = 1 << (n-1);
    int a[n][n], dp[n][V];
    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            cin >> a[i][j];
        }
    }
    for(int i=0; i<n; i++) {
        dp[i][0] = a[i][0];
    }
    for(int j=1; j<V; j++) {
        for(int i=0; i<n; i++) {
            dp[i][j] = INT_MAX;
            if(((j >> i-1) & 1) == 0) {  // 从集合j能够走到城市i-1
                for(int k=1; k<n; k++) {
                    if(((j >> k-1) & 1) == 1) { // 从城市k能够走到集合j
                        dp[i][j] = min(dp[i][j], dp[k][j^(1 << k-1)]+a[i][k]);
                        // 从i走到k再走到集合j的最省钱路径
                    }
                }
            }
        }
    }
    cout << dp[0][V-1] << endl;
}
