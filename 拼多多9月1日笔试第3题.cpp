// 拼多多9月1日笔试第3题
// 01背包变种
// 没解出来主要是因为心态爆炸+无法解决存在负容积的因素

// 来自博客  https://www.cnblogs.com/hua-dong/p/13599577.html 内含全部题解

/*
题意：普通的01背包，但是现在体积可能为负数。
思路：一眼题，因为体积为负数，表示我们的体积会变大，这种情况，我们把它变为相反数即可--------表示我一开始就装进去，那么在跑背包的时候如果选择了它的相反数这个物体，代表把它移除。（而这个时候所有的物体都是正的体积，跑01背包就行。）
注：如果你不会01背包的话，那么你在学习的时候得注意，第二个for倒序遍历，这样防止重复更新答案。或者用二维的dp。
*/

#include <bits/stdc++.h>
using namespace std;
const int maxn = 410;
int c[maxn], v[maxn], ans;
int dp[40010];

int main() {
    int n, m;
    scanf("%d%d", &n, &m);

    // 针对负容量的处理
    // 先把负容量的东西装进去 在ans变量上加上其价值 在将其价值和容量置反
    // 这样01背包正常处理过程相当于去掉该东西看能否取得更大值
    for(int i=1; i<=n; i++) {
        scanf("%d%d", &c[i], &v[i]);
        if(c[i] <= 0) {
            ans += v[i]; // 这个没想到
            m -= c[i];   // 这个想到了 主要是 数组越界问题 在实际笔试场景 就和该解法一样 设置最大范围算了 不需要思考边界了
            c[i] = -c[i];
            v[i] = -v[i];
        }
    }
    // 01背包解法 这个也能写出来
    for(int i=1; i<=n; i++) {
        for(int j=m; j>=c[i]; j--) {
            dp[j] = max(dp[j], dp[j-c[i]]+v[i]);
        }
    }
    // 这个也想到了
    for(int i=0; i<=m; i++) {
        dp[m] = max(dp[m], dp[i]);
    }
    printf("%d\n", ans + dp[m]);
    return 0;
}
