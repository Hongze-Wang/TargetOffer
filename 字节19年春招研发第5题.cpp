/*
[编程题]毕业旅行问题
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 32M，其他语言64M

小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

输入描述:
城市个数n（1<n≤20，包括北京）

城市间的车票价钱 n行n列的矩阵 m[n][n]

输出描述:
最小车费花销 s

输入例子1:
4
0 2 6 5
2 0 4 4
6 4 0 2
5 4 2 0

输出例子1:
13

例子说明1:
共 4 个城市，城市 1 和城市 1 的车费为0，城市 1 和城市 2 之间的车费为 2，城市 1 和城市 3 之间的车费为 6，城市 1 和城市 4 之间的车费为 5，依次类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。
*/

/*
我们定义dp[i][j]为从点i出发经过除了出发点0以为的集合j
（这里的集合j是使用二进制表示的一个集合，比如1，3号点二进制表示维101=5，1，2，3号点可以表示为111=7）因此举个例子，如果有4个城市0，1，2，3号城市，那么从0号城市出发，最后经过1，2，3号城市最后回到0号城市可以表示为：

dp[0][{1,2,3}] = dp[0][7] = 
min{dis[0][1]+dp[1][{2,3}],dis[0][2]+dp[2][{1,3}],dis[0][3]+dp[3][{1,2}]}
dp[1][{2,3}]的意思就是从1号点出发，经过2，3号点最后回到0号点，其他都同理就不再赘述。

通过上式不断迭代最后有dp[1][{}] 
意思就是从1号点出发不经过任何点回到0的最短距离，那么这个距离直接就是dis[1][0]
其他以此类推。有了这个递推公式后就可以用动态规划解决了
当然这种方式还是一种用空间换时间的办法，当n很大的时候也会出现无法解决的情况，这就是NP问题的棘手和复杂之处。
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    int V = 1 << (n-1); // 对1进行左移n-1位，值刚好等于2^(n-1) 它表示所有城市都在集合中的二进制表示对应的十进制数 111 -> 2^3-1 = 7 0号索引未使用
    int a[n][n], dp[n][V]; // dp表，n行，2^(n-1)列
    
    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            cin >> a[i][j];
        }
    }
    // 设想一个数组城市子集V[j]，长度为V,且V[j] = j,对于V[j]即为压缩状态的城市集合
    // 从1到V-1  用二进制表示的话，刚好可以映射成除了0号城市外的剩余n-1个城市在不在子集V[j]，1代表在，0代表不在
    // 若有总共有4个城市的话，除了第0号城市，对于1-3号城市
    // 111 = V-1 = 2^3 - 1  = 7 ，从高位到低位表示3到1号城市都在子集中
    // 而101 = 5 ，表示3,1号城市在子集中，而其他城市不在子集中
    // 这里j不仅是dp表的列坐标值，如上描述，j的二进制表示城市相应城市是否在子集中
    
    // 初始化dp表第一列
    for(int i=0; i<n; i++) {
        dp[i][0] = a[i][0];
    }
    
    for(int j=1; j<V; j++) {
        for(int i=0; i<n; i++) { //这个i不仅代表城市号，还代表第i次迭代
            dp[i][j] = INT_MAX;
            if(((j >> i-1) & 1) == 0) {  // 因为j就代表城市子集V[j],((j >> (i - 1))是把第i号城市取出来 并位与上1，等于0，说明是从i号城市出发，经过城市子集V[j]，能够回到起点0号城市
                for(int k=1; k<n; k++) {  // 这个循环要求经过子集V[j]里的城市回到0号城市的最小距离
                    if(((j >> k-1) & 1) == 1) { // 从城市k能够走到集合j
                        dp[i][j] = min(dp[i][j], dp[k][j^(1 << k-1)]+a[i][k]);  // 从i走到k再走到集合j的最省钱路径
                        // 设s=j ^ (1 << (k - 1))
                        // dp[k][j ^ (1 << (k - 1))，是将dp定位到，从k城市出发，经过城市子集V[s]，回到0号城市所花费的最小距离
                        // 怎么定位到城市子集V[s]呢，因为如果从k城市出发的，经过城市子集V[s]的话
                        // 那么V[s]中肯定不包含k了，那么在j中把第k个城市置0就可以了，而j ^ (1 << (k - 1))的功能就是这个
                        
                        // 还有怎么保证dp[k][j ^ (1 << (k - 1))]的值已经得到了呢，
                        // 注意所有的计算都是以dp表为准，从左往右从上往下的计算的，每次计算都用到左边列的数据
                        // 而dp表是有初始值的，所以肯定都能计算出来  
                    }
                }
            }
        }
    }
    cout << dp[0][V-1] << endl;
}
