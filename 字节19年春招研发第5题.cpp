/*
[编程题]毕业旅行问题
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 32M，其他语言64M

小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

输入描述:
城市个数n（1<n≤20，包括北京）

城市间的车票价钱 n行n列的矩阵 m[n][n]

输出描述:
最小车费花销 s

输入例子1:
4
0 2 6 5
2 0 4 4
6 4 0 2
5 4 2 0

输出例子1:
13

例子说明1:
共 4 个城市，城市 1 和城市 1 的车费为0，城市 1 和城市 2 之间的车费为 2，城市 1 和城市 3 之间的车费为 6，城市 1 和城市 4 之间的车费为 5，依次类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。
*/

/*
我们定义dp[i][j]为从点i出发经过除了出发点0以为的集合j
（这里的集合j是使用二进制表示的一个集合，比如1，3号点二进制表示维101=5，1，2，3号点可以表示为111=7）因此举个例子，如果有4个城市0，1，2，3号城市，那么从0号城市出发，最后经过1，2，3号城市最后回到0号城市可以表示为：

dp[0][{1,2,3}] = dp[0][7] = 
min{dis[0][1]+dp[1][{2,3}],dis[0][2]+dp[2][{1,3}],dis[0][3]+dp[3][{1,2}]}
dp[1][{2,3}]的意思就是从1号点出发，经过2，3号点最后回到0号点，其他都同理就不再赘述。

通过上式不断迭代最后有dp[1][{}] 
意思就是从1号点出发不经过任何点回到0的最短距离，那么这个距离直接就是dis[1][0]
其他以此类推。有了这个递推公式后就可以用动态规划解决了
当然这种方式还是一种用空间换时间的办法，当n很大的时候也会出现无法解决的情况，这就是NP问题的棘手和复杂之处。
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    int V = 1 << (n-1);
    int a[n][n], dp[n][V];
    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            cin >> a[i][j];
        }
    }
    for(int i=0; i<n; i++) {
        dp[i][0] = a[i][0];
    }
    for(int j=1; j<V; j++) {
        for(int i=0; i<n; i++) {
            dp[i][j] = INT_MAX;
            if(((j >> i-1) & 1) == 0) {  // 从集合j能够走到城市i-1
                for(int k=1; k<n; k++) {
                    if(((j >> k-1) & 1) == 1) { // 从城市k能够走到集合j
                        dp[i][j] = min(dp[i][j], dp[k][j^(1 << k-1)]+a[i][k]);
                        // 从i走到k再走到集合j的最省钱路径
                    }
                }
            }
        }
    }
    cout << dp[0][V-1] << endl;
}
